We need to provide linker script for our microcontroller. This file is strictly related to architecture of our device. We will create our one and will explain each line of it in the comments.

You should create file `linker.ld` in your project. In next steps we will rename files to be compliant with most of STM32 projects.

This file is created basing on file generated by STM32Cube. It is common to use a template and modify only if we need to.

```ld
ENTRY(Reset_Handler)
```
- First function that will be executed after microcontroller reset.

```ld
_estack = 0x20080000;    /* end of RAM */
```
- Stack is usually located at the end of RAM. This memory region in STM32F767 is located on `0x2000000` address:
  https://www.st.com/resource/en/reference_manual/rm0410-stm32f76xxx-and-stm32f77xxx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf

  ![](assets/Pasted%20image%2020240324032206.png)

- Our STM32F767 has 512 KBytes of SRAM:
  https://www.st.com/resource/en/datasheet/stm32f765bi.pdf

  ![](assets/Pasted%20image%2020240324031736.png)
- So to calculate end of stack we neeed to convert 512KBytes to bytes in hex:
	- 512KB * 1024B = 524288 B = 0x80000 B (hex)
	- And next add this offset to SRAM location:
	  0x2000000 + 0x80000 = 0x20080000

```ld
_Min_Heap_Size = 0x200;  /* required amount of heap  */
_Min_Stack_Size = 0x400; /* required amount of stack */
```
- We can define minimal required values of heap and stack. It is not necessary, but it will allow us to raise compile error if our static variables allocates too much memory. Those values will be used later in linker script file.

```ld
MEMORY
{
RAM (xrw)      : ORIGIN = 0x20000000, LENGTH = 512K
FLASH (rx)      : ORIGIN = 0x8000000, LENGTH = 2048K
}
```
- First we have to define available memory areas in our microcontroller. In this case we defined RAM and FLASH according to microcontroller's datasheet. We can split FLASH into two banks and SRAM into SRAM1, SRAM2 and DTCM-RAM.
- AFAIK there is no difference between SRAM1 and SRAM2, but you can for example disable cache on SRAM2 and speed up DMA transfers there, while SRAM1 will be used by CPU with cache. DTCM-RAM is not connected to CPU via Bus Matrix. It means that access to this memory is faster.

```ld
SECTIONS
{
}
```
- In this section we define data sections and can locate them in our memory areas.

```ld
  .isr_vector :
  {
    . = ALIGN(4);
    KEEP(*(.isr_vector)) /* Startup code */
    . = ALIGN(4);
  } >FLASH
```
- `. =` Means that we are setting current memory pointer to specific location. In this case we align it to te next value that is multiply of 4.
- Interrupts vector array should be located at the beginning of the BOOT memory. In our case it means - FLASH memory.
- `KEEP` means that linker should not delete this section - even if it seems not to be used in code.

```ld
  .text :
  {
    . = ALIGN(4);
    *(.text)           /* .text sections (code) */
    *(.text*)          /* .text* sections (code) */
    *(.glue_7)         /* glue arm to thumb code */
    *(.glue_7t)        /* glue thumb to arm code */
    *(.eh_frame)

    KEEP (*(.init))
    KEEP (*(.fini))

    . = ALIGN(4);
    _etext = .;        /* define a global symbols at end of code */
  } >FLASH
```
- `.text` section contains executable code
- `*(.text)` means that we want to put into this section whole data from `.text`
- `*(.text*)` means that we want to put here every section starting with `.text`. "`*`" is a wildcard here.
- `.glue_7` and `.glue_7t` are section specific to Cortex-M7 core. Compiler can put code for jumping between ARM ant Thumb mode into those sections. More info here: https://developer.arm.com/documentation/ddi0210/latest/CACBCAAE
- `.eh_frame` section is mostly used by C++ language. It means `exception handling frame` and it is used during stack unwinding.
- `.fini` section is responsible for freeing resources on application exit / library unmounting
- `_etext` symbol is defined here and will point do the end address of `.text` section.

```ld
  /* Constant data goes into FLASH */
  .rodata :
  {
    . = ALIGN(4);
    *(.rodata)         /* .rodata sections (constants, strings, etc.) */
    *(.rodata*)        /* .rodata* sections (constants, strings, etc.) */
    . = ALIGN(4);
  } >FLASH
```
- `.rodata` section contains read-only data - constants, strings and other non-variable objects.

```ld
  .ARM.extab   : { *(.ARM.extab* .gnu.linkonce.armextab.*) } >FLASH
  .ARM : {
    __exidx_start = .;
    *(.ARM.exidx*)
    __exidx_end = .;
  } >FLASH
```
- `ARM` - section specific for ARM architecture
- `.ARM.extab` - contains exception tables which are used to handle exception in ARM (stack unwinding)
- `.ARM.exidx*` - contains data needed to unwind stack on exception

```ld
  .preinit_array     :
  {
    PROVIDE_HIDDEN (__preinit_array_start = .);
    KEEP (*(.preinit_array*))
    PROVIDE_HIDDEN (__preinit_array_end = .);
  } >FLASH
```
- `.preinit_array` section is responsible for managing all initialization that take place before running `main()` function
- `PROVIDE_HIDDEN`:
	- `PROVIDE` - defines linker symbol **without overwriting existing one**
	- `HIDDEN` - hides symbols between separated libraries
- `.preinit_array*` contains pointers to functions that should be called before every constructors of C++ object instances

```ld
  .init_array :
  {
    PROVIDE_HIDDEN (__init_array_start = .);
    KEEP (*(SORT(.init_array.*)))
    KEEP (*(.init_array*))
    PROVIDE_HIDDEN (__init_array_end = .);
  } >FLASH
```
- `.init_array` contains global initializers and constructors

```ld
  .fini_array :
  {
    PROVIDE_HIDDEN (__fini_array_start = .);
    KEEP (*(SORT(.fini_array.*)))
    KEEP (*(.fini_array*))
    PROVIDE_HIDDEN (__fini_array_end = .);
  } >FLASH
```
- `fini_array` contains destructors or functions that should be called during unlinking dynamic librariers

```ld
  /* used by the startup to initialize data */
  _sidata = LOADADDR(.data);

  /* Initialized data sections goes into RAM, load LMA copy after code */
  .data : 
  {
    . = ALIGN(4);
    _sdata = .;        /* create a global symbol at data start */
    *(.data)           /* .data sections */
    *(.data*)          /* .data* sections */

    . = ALIGN(4);
    _edata = .;        /* define a global symbol at data end */
  } >RAM AT> FLASH
```
- `_sidata` defines symbol that contains source address of `.data` section (section with initialization values)
- `.data` this section contains variables that are initialized with specific values
- `_sdata`, `_edata` - symbols that contains start and end address of `._data` section
- `>RAM AT> FLASH` - means that data from `.data` section should be placed in RAM but should be loaded from FLASH. This is crucial because RAM memory in STM32 is volatile and it is erased at every system restart.

```ld
  /* Uninitialized data section */
  . = ALIGN(4);
  .bss :
  {
    /* This is used by the startup in order to initialize the .bss secion */
    _sbss = .;         /* define a global symbol at bss start */
    __bss_start__ = _sbss;
    *(.bss)
    *(.bss*)
    *(COMMON)

    . = ALIGN(4);
    _ebss = .;         /* define a global symbol at bss end */
    __bss_end__ = _ebss;
  } >RAM
```
- `.bss` this section contains uninitialized variables which should be cleared on startup
- `COMMON` usually used by compiler in global variables that are not placed in specific section

```ld
  /* User_heap_stack section, used to check that there is enough RAM left */
  ._user_heap_stack :
  {
    . = ALIGN(8);
    PROVIDE ( end = . );
    PROVIDE ( _end = . );
    . = . + _Min_Heap_Size;
    . = . + _Min_Stack_Size;
    . = ALIGN(8);
  } >RAM
```
- `._user_heap_stack` - this section is created to control free RAM memory.
- `. = . + _Min_Heap_Size;` add `_Min_Heap_Size` to current address

```ld
  /* Remove information from the standard libraries */
  /DISCARD/ :
  {
    libc.a ( * )
    libm.a ( * )
    libgcc.a ( * )
  }

  .ARM.attributes 0 : { *(.ARM.attributes) }
```
- `/DISCARD/` - this section defines sections / symbols that can be discarded during lining process. It can be used to minimalize result size of binary
- `.ARM.attributes` - contains executable attributes:

  ![](assets/Pasted%20image%2020240324233500.png)
 -  `0:` - means that section doesn't have specified type (RAM or FLASH)

## Compile time

We need to provide our linker script to build commad:
```patch
++ LDFLAGS= -specs=nosys.specs
++ LDFLAGS= -specs=nosys.specs -TSTM32F767ZITx_FLASH.ld
```

Now we can build our project:
```powershell
arm-none-eabi-gcc -c  main.c -o main.o
arm-none-eabi-gcc -c  syscalls.c -o syscalls.o
arm-none-eabi-gcc -specs=nosys.specs -TSTM32F767ZITx_FLASH.ld main.o syscalls.o -o main.elf
C:/ST/STM32CubeCLT/GNU-tools-for-STM32/bin/../lib/gcc/arm-none-eabi/11.3.1/../../../../arm-none-eabi/bin/ld.exe: warning: cannot find entry symbol Reset_Handler; defaulting to 0000000008000000
arm-none-eabi-objcopy -O binary main.elf main.bin
```

## Conclusion
Symbol `Reset_Handler` is not defined. There are more things that we should define. For example - our processor should know, that we have `main()` function and it should be called after processor starting.